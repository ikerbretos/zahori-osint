import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { PrismaClient } from '@prisma/client';
import { ipLookup, dnsLookup, emailLookup, phoneLookup } from './modules/osint';

dotenv.config();

const app = express();
const prisma = new PrismaClient();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

// Cases
app.get('/api/cases', async (req, res) => {
    const cases = await prisma.case.findMany({
        include: { _count: { select: { nodes: true, links: true } } }
    });
    res.json(cases);
});

app.post('/api/cases', async (req, res) => {
    const { name, description } = req.body;
    const newCase = await prisma.case.create({
        data: { name, description }
    });
    res.json(newCase);
});

app.get('/api/cases/:id', async (req, res) => {
    const { id } = req.params;
    const caseData = await prisma.case.findUnique({
        where: { id },
        include: { nodes: true, links: true }
    });
    res.json(caseData);
});

// Update Case Graph
app.post('/api/cases/:id/graph', async (req, res) => {
    const { id } = req.params;
    const { nodes, links } = req.body;

    await prisma.$transaction([
        prisma.node.deleteMany({ where: { caseId: id } }),
        prisma.link.deleteMany({ where: { caseId: id } }),
        prisma.node.createMany({
            data: nodes.map((n: any) => ({
                id: n.id,
                type: n.type,
                data: JSON.stringify(n.data),
                notes: n.notes || '',
                x: n.x,
                y: n.y,
                caseId: id
            }))
        }),
        prisma.link.createMany({
            data: links.map((l: any) => ({
                id: l.id,
                source: l.source,
                target: l.target,
                caseId: id
            }))
        })
    ]);

    res.json({ success: true });
});

// OSINT Enrichment
app.post('/api/enrich', async (req, res) => {
    const { nodeId, type, searchValue, apiKeys } = req.body;
    let result = null;

    console.log(`[API] Enrichment request for type: ${type}, value: ${searchValue}`);

    if (type === 'ip') {
        result = await ipLookup(searchValue, apiKeys?.shodan, apiKeys?.abuseipdb, apiKeys?.virustotal);
    } else if (type === 'domain') {
        result = await dnsLookup(searchValue);
    } else if (type === 'email') {
        result = await emailLookup(searchValue, apiKeys?.hunter);
    } else if (type === 'phone') {
        result = await phoneLookup(searchValue, apiKeys?.numverify);
    }

    res.json({ success: !!result, result });
});

// --- NEW PLUGIN SYSTEM API ---

import { pluginManager } from './modules/core/PluginRegistry';

// Get available plugins for a type
app.get('/api/plugins', (req, res) => {
    const { type } = req.query;
    if (type) {
        const plugins = pluginManager.getPluginsForType(String(type));
        res.json(plugins.map(p => ({
            name: p.name,
            description: p.description,
            cost: p.cost,
            author: p.author
        })));
    } else {
        // Return all ? Or error? Let's return all categorized maybe?
        // deeper introspection needed for "all", for now let's just assume query param is used.
        res.json([]);
    }
});

// Execute a plugin on a node
app.post('/api/expand', async (req, res) => {
    const { nodeId, pluginName, config } = req.body;

    try {
        // 1. Fetch Node from DB
        const node = await prisma.node.findUnique({ where: { id: nodeId } });

        if (!node) {
            return res.status(404).json({ error: "Node not found" });
        }

        // 2. Execute Plugin
        const results = await pluginManager.executePlugin(pluginName, node, config);

        // 3. Save Results Transcationally
        // We need to associate new nodes to the same Case ID as the parent node.
        const caseId = node.caseId;

        const createdNodes = [];
        const createdLinks = [];

        await prisma.$transaction(async (tx) => {
            for (const n of results.newNodes) {
                const created = await tx.node.create({
                    data: {
                        id: n.id, // Use ID generated by plugin or let DB? Plugin generated IDs are temp unless UUID. 
                        // Plugin uses random string. Let's trust it for now but UUID is better.
                        // If plugin uses "auto_...", we might want to replace it. 
                        // BUT, the links reference these IDs. So we must keep them consistent.
                        type: n.type!,
                        data: n.data!,
                        x: n.x!,
                        y: n.y!,
                        caseId: caseId
                    }
                });
                createdNodes.push(created);
            }

            for (const l of results.newLinks) {
                const created = await tx.link.create({
                    data: {
                        source: l.source!,
                        target: l.target!,
                        caseId: caseId
                    }
                });
                createdLinks.push(created);
            }
        });

        res.json({
            success: true,
            logs: results.logs,
            newNodesCount: createdNodes.length,
            newLinksCount: createdLinks.length
        });

    } catch (error: any) {
        console.error("Plugin Execution Error:", error);
        res.status(500).json({ error: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
